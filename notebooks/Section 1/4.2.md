# Protocol 4.1.2: Parallel WEPP Execution and Result Rasterization

---

## 1. Objective

To execute the Water Erosion Prediction Project (WEPP) model in a massively parallel fashion for every delineated hillslope. This involves creating a Python wrapper for the WEPP command-line interface, parsing the model's text-based output files, and rasterizing the primary result—average annual sediment yield—into the final target variable raster for the project.

## 2. Rationale and Strategic Justification

This protocol represents the fusion of your entire preparatory framework into a single, high-impact scientific output. The act of wrapping and parallelizing a complex, external scientific model demonstrates a high level of intellectual mastery and technical skill. This is where the abstract power of your Dynamic Resource Allocation Framework becomes a tangible tool of service, enabling a computationally prohibitive task to be completed efficiently. The final deliverable—a beautiful, continuous raster surface of process-based erosion—is the ultimate prize of this entire data engineering phase. It is the core data product upon which your central hypothesis ($H_2$) will be tested, making the successful execution of this protocol a pivotal moment for the project.

## 3. Implementation Protocol (Jupyter Notebook Workflow)

### Step 1: Develop the WEPP Execution Wrapper Function
* **Input:** The master job list (`wepp_job_list.csv`).
* **Process:**
    1.  Write a core Python function that takes a single row from the job list DataFrame as input.
    2.  Inside the function, use Python's `subprocess` module to construct and execute the WEPP command-line call. The command will look something like: `wepp path/to/slope.slp path/to/soil.sol path/to/climate.cli path/to/output.txt`.
    3.  After the subprocess completes, the function must open the specified WEPP output file (`output.txt`).
    4.  Write parsing logic to read this text file, find the line containing "Avg Ann Sed Yield," and extract the numerical value (typically in kg/m²).
    5.  The function should return this single floating-point value. Include robust error handling for cases where the model fails or the output is unparseable.

### Step 2: Execute WEPP in Parallel with Dask
* **Input:** The WEPP execution wrapper function and the master job list.
* **Process:**
    1.  Initialize the Dask `LocalCluster` using the dynamic resource allocation logic defined in your framework.
    2.  Use the `dask.bag` or `dask.delayed` interface to apply your wrapper function to every row of the job list in parallel.
    3.  Compute the result. Dask will distribute the thousands of WEPP runs across all available CPU cores, dramatically reducing the total runtime from weeks or months to a manageable timeframe.
    4.  Collect the results—a list or array of sediment yield values, in the same order as the job list.

### Step 3: Join Results and Rasterize
* **Input:** The vector layer of subwatersheds (`subwatersheds.gpkg`) and the computed sediment yield results.
* **Process:**
    1.  Join the sediment yield results back to the subwatersheds GeoDataFrame based on their unique IDs.
    2.  Use the `rasterio.features.rasterize` function to "burn" the sediment yield value from each polygon feature into a new raster array.
    3.  This operation requires a template grid; use the original clipped DEM (`dem_mosaic_clipped.tif`) to ensure the final output has the exact same extent, resolution, and CRS.
* **Output:** The final target variable raster (`sediment_yield.tif`).


## 4. Deliverables

1.  **Primary Target Variable Raster:** A single GeoTIFF file named `sediment_yield.tif` stored in `data/processed/`. This raster represents the average annual sediment yield and will be the dependent variable for the process-prediction modeling ($H_2$).
2.  **Jupyter Notebook (`07_execute_wepp_and_rasterize.ipynb`)**: A fully executed notebook containing:
    * The Python wrapper for the WEPP executable.
    * The Dask parallel execution code.
    * The final rasterization code.
    * A visualization of the final `sediment_yield.tif` raster.

## 5. Quality Control Checklist

* [ ] The WEPP wrapper function correctly calls the model and parses the output for a single test case.
* [ ] The Dask parallel run completes without errors for the full job list.
* [ ] The number of results matches the number of input hillslopes.
* [ ] The final rasterized output is co-registered with the project's other data layers (same extent, CRS, and cell size).
* [ ] The sediment yield values in the final raster are physically plausible.