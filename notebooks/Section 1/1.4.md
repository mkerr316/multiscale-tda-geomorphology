### Phase 1: Research, Design, and Setup (The Blueprint)

This phase is about understanding the tools and designing the notebook's structure before writing the main code.

* **[ ] 1.1: Identify the WEPPcloud API/Client:**
    * **Task:** The first and most critical step is to investigate how to interact with WEPPcloud programmatically.
    * **Action:** Search for "WEPPcloud API documentation" or a "Python client for WEPPcloud". The goal is to find the specific functions for submitting a job and retrieving results.
    * **Note:** A quick search reveals that WEPPcloud is built on a REST API. You will likely be using a library like `requests` in Python to send JSON objects to the API endpoints.

* **[ ] 1.2: Design the Notebook's Core Logic:**
    * **Task:** Outline the essential steps the notebook will perform.
    * **Action:** Create a markdown skeleton in a new Jupyter notebook that defines the logical flow:
        1.  **Configuration:** Load study area and run parameters.
        2.  **Job Submission:** Send the AOI and parameters to WEPPcloud.
        3.  **Status Monitoring:** Periodically check if the job is complete.
        4.  **Result Retrieval:** Download the final raster once the job is done.
        5.  **Validation:** Verify the downloaded raster.

* **[ ] 1.3: Define the Configuration (`config.yml`):**
    * **Task:** Specify all user-configurable parameters in your central `config.yml` file.
    * **Action:** Add a new `weppcloud` section to your config file. The key parameters to include are:
        * `aoi_path`: Path to your study area shapefile.
        * `simulation_years`: Set this to `100` for a robust, stable average.
        * `output_directory`: Where to save the final raster.
        * `project_name`: A descriptive name for the WEPPcloud run.

***

### Phase 2: Core Implementation (Building the Engine)

This is where you write the Python functions that will interact with the WEPPcloud service. It's best practice to put these in a new `.py` file within your `src` directory (e.g., `src/weppcloud_client.py`).

* **[ ] 2.1: Implement the Job Submission Function:**
    * **Task:** Write a function that takes your study area and run parameters, packages them into the required format (likely a JSON object), and sends a POST request to the WEPPcloud API's "run" endpoint.
    * **Action:** The function should return a unique `job_id` provided by the API, which you will use to track the simulation's progress.

* **[ ] 2.2: Implement the Status Monitoring Function:**
    * **Task:** Create a function that takes a `job_id` and sends a GET request to the API's "status" endpoint.
    * **Action:** The function should parse the response to determine if the job is `running`, `completed`, or `failed`. Implement a `while` loop with a `time.sleep()` call to poll the status every few minutes until it is no longer `running`.

* **[ ] 2.3: Implement the Result Download Function:**
    * **Task:** Write a function that takes a `job_id` and the desired output path.
    * **Action:** Once the status is `completed`, this function will query an API "download" endpoint to get the URL of the output raster and will then use your existing `download_core.py` utilities to save the file.

***

### Phase 3: Workflow Orchestration (The Assembly Line)

This phase involves creating the new Jupyter notebook itself, which will act as the user-friendly interface to your powerful backend functions.

* **[ ] 3.1: Create the "Target Variable Generation" Notebook:**
    * **Task:** Create a new notebook (e.g., `1.6_generate_target_variable.ipynb`).
    * **Action:** Following your established "Gold-Standard Practices," start the notebook with a clear objective, import necessary libraries, and load the `weppcloud` section from your `config.yml`.

* **[ ] 3.2: Execute the End-to-End Workflow:**
    * **Task:** Write the notebook cells to call your core functions in sequence.
    * **Action:**
        1.  Call the `submit_job` function. Print the returned `job_id`.
        2.  Call the `monitor_status` function, providing clear log messages as it checks the job's progress.
        3.  Once complete, call the `download_result` function.
        4.  End with a clear message indicating success or failure.

***

### Phase 4: Production and Validation (Quality Control)

This final phase turns a working script into a piece of reproducible science.

* **[ ] 4.1: Implement Robust Error Handling:**
    * **Task:** Ensure the notebook can handle common problems gracefully.
    * **Action:** Wrap your API calls in `try...except` blocks to catch potential network errors or API failures. If a WEPPcloud job fails, the notebook should report the failure clearly instead of crashing.

* **[ ] 4.2: Add a Post-Flight Validation Step:**
    * **Task:** Programmatically verify that the final raster is valid.
    * **Action:** After downloading the result, use `rasterio` to:
        * Confirm the file can be opened and is not corrupt.
        * Check that its Coordinate Reference System (CRS) matches your project's standard CRS.
        * Verify that its extent and resolution are consistent with your input DEM.

* **[ ] 4.3: Document the Process:**
    * **Task:** Write clear markdown cells explaining each step of the process.
    * **Action:** Describe what each code cell does, what the expected output is, and why key decisions (like the 100-year simulation length) were made, citing the relevant project documents. This documentation is essential for the long-term value and reproducibility of your work.