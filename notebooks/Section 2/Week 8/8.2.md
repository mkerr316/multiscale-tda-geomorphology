# Protocol 8.2: Generating a Multi-Vectorization Suite of TLSP Rasters

**Document Version:** 1.0
**Date:** September 27, 2025
**Associated Project Task:** 8.2 - Generate the final suite of TLSP raster layers using both Persistence Landscape and Persistence Image vectorizations.
**Corresponding Notebook:** `17_generate_multi_vector_tlsp_rasters.ipynb`

---

## 1. Objective

To expand the production TDA pipeline to generate a comprehensive suite of TLSP raster layers using two distinct and complementary vectorization methods: **Persistence Landscapes (PL)** and **Persistence Images (PI)**. This involves refactoring the core TDA function to be modular with respect to the vectorization technique and executing the pipeline for each required combination of homology dimension and vectorization method.

## 2. Rationale and Strategic Justification

This protocol is an act of profound **intellectual mastery** and a direct fulfillment of the project's commitment to methodological robustness [cite: Geomorphometry Methods and Metrics Discussion.md]. By generating TLSPs from multiple vectorization schemes, you are not just creating more data; you are building a more beautiful, complete, and harmonically rich feature set. This allows the downstream machine learning models to "see" the landscape's topology through different mathematical lenses, increasing the chances of discovering the most predictive and meaningful representation.

This structured comparison is an "enthusiast-grade" approach that moves beyond a simplistic application of a single method. The **tangible service** is the creation of a powerful, multi-faceted suite of novel covariates that will enable a rigorous head-to-head comparison in the modeling phase (Task 12), providing a deeper and more credible answer to your core scientific questions.

## 3. Implementation Protocol (Jupyter Notebook Workflow)

### Step 1: Refactor the Core TDA Function for Modularity
This is the key software engineering step that enables the entire protocol.

* **Process:**
    1.  Open your utility script, `src/tda_utils.py`.
    2.  Modify the core `calculate_local_topology` function signature to accept a new parameter: `def calculate_local_topology(window, homology_dim=1, invert=False, vectorization_method='landscape'):`
    3.  Inside the function, after computing the persistence diagram with `ripser.py`, add a conditional block (e.g., `if/elif/else`):
        * If `vectorization_method == 'landscape'`: Use the `persim` library to compute the Persistence Landscape from the diagram. Return a summary statistic (e.g., the integral of the first landscape function, `L1_norm`).
        * If `vectorization_method == 'image'`: Use `persim` to compute the Persistence Image. Return a summary statistic (e.g., the total pixel intensity).
        * Else: Raise an error for an unsupported method.
    4.  This refactoring makes your core function a flexible, powerful instrument capable of producing different topological summaries on demand.

### Step 2: Execute the Pipeline for All Four TLSP Variants
This is the main execution phase, which will be performed in the `17_generate_multi_vector_tlsp_rasters.ipynb` notebook.

* **Input:**
    * The primary conditioned DEM (`data/processed/dem_filled.tif`).
    * The newly refactored utility functions from `src/tda_utils.py`.
* **Process:**
    1.  Initialize your dynamic Dask client as before.
    2.  Load the full DEM for your study areas as a Dask-backed `rioxarray` object.
    3.  You will now execute the `generate_tlsp_raster` wrapper function four times, passing the appropriate parameters to the underlying core function. For each run, trigger the computation with `.compute()` and save the final, georeferenced GeoTIFF.

| Homology ($H_k$) | Landscape Feature | Vectorization | `invert` Param | `homology_dim` Param | `vectorization_method` Param | Output Filename |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **$H_1$** | Pits/Basins | Landscape | `False` | `1` | `'landscape'` | `tlsp_h1_pits_pl.tif` |
| **$H_1$** | Pits/Basins | Image | `False` | `1` | `'image'` | `tlsp_h1_pits_pi.tif` |
| **$H_0$** | Peaks/Ridges | Landscape | `True` | `0` | `'landscape'` | `tlsp_h0_peaks_pl.tif` |
| **$H_0$** | Peaks/Ridges | Image | `True` | `0` | `'image'` | `tlsp_h0_peaks_pi.tif` |



## 4. Deliverables

1.  **Refactored TDA Utility Script (`src/tda_utils.py`)**: The updated script containing the modular `calculate_local_topology` function that can handle multiple vectorization methods.
2.  **Final TLSP Covariate Suite:** The four novel raster data products, stored in `data/processed/covariates/unstandardized/`:
    * `tlsp_h1_pits_pl.tif` (Persistence Landscape)
    * `tlsp_h1_pits_pi.tif` (Persistence Image)
    * `tlsp_h0_peaks_pl.tif` (Persistence Landscape)
    * `tlsp_h0_peaks_pi.tif` (Persistence Image)
3.  **Jupyter Notebook (`17_generate_multi_vector_tlsp_rasters.ipynb`)**: A fully executed notebook that:
    * Imports the refactored, modular function.
    * Executes the parallel pipeline four times to generate the complete suite of TLSP layers.
    * Saves all final GeoTIFF files.
    * Includes visualizations of all four final TLSP rasters for comparison.

## 5. Quality Control Checklist

* [ ] The `calculate_local_topology` function has been successfully refactored to support both `'landscape'` and `'image'` vectorizations.
* [ ] The parallel pipeline executes successfully for all four combinations of parameters.
* [ ] All four output raster files are generated, correctly named, and properly georeferenced.
* [ ] The output rasters are visually inspected and show plausible geomorphic patterns.
* [ ] The entire generation process is documented and reproducible via the notebook.